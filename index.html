<!DOCTYPE html>
<html lang="zh-Hant">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>親子象棋 (Xiangqi)</title>

<!-- ===== 樣式 ===== -->
<style>
  :root{
    --cell:60px;
    --wood-light:#f6e4c0;
    --wood-dark:#d3a46f;
    --line:#3d2b1f;
    --orange:#ff6b00;
  }
  *{box-sizing:border-box;-webkit-user-select:none;user-select:none}
  body{
    margin:0;min-height:100vh;display:flex;justify-content:center;
    align-items:flex-start;font-family:"Segoe UI",Roboto,"Noto Sans",sans-serif;
    background:linear-gradient(135deg,#fdfbfb 0%,#ebedee 100%);
  }
  h1{font-size:2rem;margin:0 0 1rem;text-align:center;color:#333;}

  /* 卡片 */
  .card{background:#fff;border-radius:14px;padding:2rem 2.5rem;
        box-shadow:0 8px 20px rgba(0,0,0,.15);
        display:flex;flex-direction:column;align-items:center}

  /* 按鈕 & 選單 */
  button,select{padding:.6rem 1.4rem;font-size:1rem;border:none;
                border-radius:10px;cursor:pointer;transition:.2s;font-weight:600}
  button{background:var(--orange);color:#fff;box-shadow:0 2px 6px rgba(0,0,0,.15)}
  button:hover{transform:translateY(-2px);box-shadow:0 4px 10px rgba(0,0,0,.25)}
  select{background:#f9f9f9;border:1px solid #ccc}

  #menu{gap:.9rem}
  #difficultyRow{display:flex;align-items:center;gap:.5rem}

  /* 棋盤 & 時鐘 */
  #board{border:4px solid var(--line);border-radius:8px;touch-action:none;
         box-shadow:0 6px 16px rgba(0,0,0,.25);margin-top:1rem}
  #toolbar{margin-top:.8rem;gap:1rem;display:flex;justify-content:center}
  #msg{margin-top:.6rem;font-weight:600;font-size:1.1rem;color:#444;text-align:center}
  #clockWrapper{margin-top:.6rem;display:flex;justify-content:center;
                gap:3rem;font-size:1.1rem;font-weight:700}
  .timeBox{background:#fff;border:2px solid var(--orange);border-radius:8px;
           padding:.3rem 1rem;min-width:80px;text-align:center}

  /* 結束畫面 */
  #overlay{position:fixed;inset:0;background:rgba(0,0,0,.6);
           display:flex;justify-content:center;align-items:center;
           z-index:100;visibility:hidden;opacity:0;transition:.3s}
  #overlay.show{visibility:visible;opacity:1}
  #overlayContent{background:#fff;border-radius:16px;
                  padding:2rem 3rem;text-align:center;
                  box-shadow:0 8px 20px rgba(0,0,0,.3)}
  #overlayContent h2{font-size:2rem;margin:0 0 1rem;color:var(--orange)}
</style>
</head>
<body>

  <!-- 首頁 -->
  <div class="card" id="menu">
    <h1>親子象棋 (Xiangqi)</h1>

    <button id="singleBtn">單人模式 (VS 電腦)</button>

    <div id="difficultyRow">
      <label for="level">難度：</label>
      <select id="level">
        <option value="easy">簡單</option>
        <option value="normal">普通</option>
        <option value="hard">困難</option>
      </select>
    </div>

    <div id="timeRow" style="margin-top:.3rem;display:flex;align-items:center;gap:.5rem">
      <label for="timeSelect">每方時間：</label>
      <select id="timeSelect">
        <option value="300">5 分鐘</option>
        <option value="600">10 分鐘</option>
        <option value="900">15 分鐘</option>
      </select>
    </div>

    <button id="doubleBtn">雙人模式 (本機)</button>
  </div>

  <!-- 棋盤 -->
  <canvas id="board" width="540" height="600" hidden></canvas>

  <!-- 時鐘 -->
  <div id="clockWrapper" hidden>
    <div class="timeBox" id="redClock">05:00</div>
    <div class="timeBox" id="blackClock">05:00</div>
  </div>

  <!-- 工具列 -->
  <div id="toolbar" hidden>
    <button id="restartBtn">重新開始</button>
    <button id="backBtn">返回首頁</button>
  </div>

  <div id="msg"></div>

  <!-- 結束畫面 -->
  <div id="overlay">
    <div id="overlayContent">
      <h2 id="resultText">紅方勝！</h2>
      <button onclick="hideOverlay()">關閉</button>
    </div>
  </div>

<!-- ===== 腳本 ===== -->
<script>
/* ---- 音效 ---- */
const moveSound=new Audio('https://actions.google.com/sounds/v1/cartoon/pop.ogg');
const endSound =new Audio('https://actions.google.com/sounds/v1/cartoon/clang_and_wobble.ogg');
moveSound.volume=.4; endSound.volume=.5;

/* ---- 棋盤資料 ---- */
const ROWS=10,COLS=9,CELL=60;
const INFO={r:{n:'車',s:'black'},n:{n:'馬',s:'black'},b:{n:'象',s:'black'},a:{n:'士',s:'black'},k:{n:'將',s:'black'},c:{n:'炮',s:'black'},p:{n:'卒',s:'black'},R:{n:'車',s:'red'},N:{n:'馬',s:'red'},B:{n:'相',s:'red'},A:{n:'仕',s:'red'},K:{n:'帥',s:'red'},C:{n:'炮',s:'red'},P:{n:'兵',s:'red'}};
const VAL={k:1e4,r:500,n:300,b:250,a:120,c:280,p:70};
const initBoard=()=>[['r','n','b','a','k','a','b','n','r'],[,,,,,,,,],[,'c',,,,,,'c',],['p',,'p',,'p',,'p',,'p'],[,,,,,,,,],[,,,,,,,,],['P',,'P',,'P',,'P',,'P'],[,'C',,,,,,'C',],[,,,,,,,,],['R','N','B','A','K','A','B','N','R']];

/* ---- DOM ---- */
const canvas=document.getElementById('board'),ctx=canvas.getContext('2d');
const menu=document.getElementById('menu'),toolbar=document.getElementById('toolbar');
const msgEl=document.getElementById('msg'),clockWrap=document.getElementById('clockWrapper');
const redClock=document.getElementById('redClock'),blackClock=document.getElementById('blackClock');
const overlay=document.getElementById('overlay'),resultText=document.getElementById('resultText');

/* ---- 狀態 ---- */
let board,current,selected,running,mode,aiSide,aiDepth;
let redTime,blackTime,timer,active;

/* ---- 入口 ---- */
document.getElementById('singleBtn').onclick=()=>start('single');
document.getElementById('doubleBtn').onclick=()=>start('double');
document.getElementById('restartBtn').onclick=()=>start(mode);
document.getElementById('backBtn').onclick=home;

/* ---- 函數 ---- */
function home(){stopTimer();running=false;
  canvas.hidden=true;toolbar.hidden=true;clockWrap.hidden=true;
  menu.style.display='flex';msgEl.textContent='';
}

function start(m){
  mode=m;board=initBoard();current='red';selected=null;running=true;
  aiSide=(mode==='single')?'black':null;
  const diff=document.getElementById('level').value;
  aiDepth=diff==='easy'?1:diff==='normal'?2:3;
  redTime=blackTime=parseInt(document.getElementById('timeSelect').value,10);
  updateClocks();

  menu.style.display='none';
  canvas.hidden=false;toolbar.hidden=false;clockWrap.hidden=false;
  msgEl.textContent='紅方先行';render();switchTimer('red');
  if(aiSide==='red') setTimeout(aiMove,300);
}

/* ---- 計時 ---- */
function updateClocks(){redClock.textContent=format(redTime);blackClock.textContent=format(blackTime);}
const format=s=>`${String(Math.floor(s/60)).padStart(2,'0')}:${String(s%60).padStart(2,'0')}`;
function switchTimer(side){stopTimer();active=side;
  timer=setInterval(()=>{if(side==='red'){if(--redTime<=0)over('紅方超時敗！');}
                         else{if(--blackTime<=0)over('黑方超時敗！');}
                         updateClocks();},1000);}
function stopTimer(){if(timer){clearInterval(timer);timer=null;}}

/* ---- 走規則 ---- */
const inR=(r,c)=>r>=0&&r<ROWS&&c>=0&&c<COLS;
const sameS=(a,b)=>a&&b&&INFO[a].s===INFO[b].s;
const palace=(s,r,c)=>s==='red'?r>=7&&c>=3&&c<=5:r<=2&&c>=3&&c<=5;
const across=(s,r)=>s==='red'?r<=4:r>=5;
function clearP(sr,sc,tr,tc){const dr=Math.sign(tr-sr),dc=Math.sign(tc-sc);
  for(let r=sr+dr,c=sc+dc;r!==tr||c!==tc;r+=dr,c+=dc)if(board[r][c])return false;return true;}
function can(sr,sc,tr,tc){
  if(!inR(tr,tc)||sameS(board[sr][sc],board[tr][tc]))return false;
  const p=board[sr][sc];if(!p)return false;const s=INFO[p].s;
  const dr=tr-sr,dc=tc-sc,aR=Math.abs(dr),aC=Math.abs(dc);
  switch(p.toLowerCase()){
    case'r':return(sr===tr||sc===tc)&&clearP(sr,sc,tr,tc);
    case'n':if(!((aR===2&&aC===1)||(aR===1&&aC===2)))return false;
             return !board[sr+(aR===2?dr/2:0)][sc+(aC===2?dc/2:0)];
    case'b':return aR===2&&aC===2&&!across(s,tr)&&!board[sr+dr/2][sc+dc/2];
    case'a':return aR===1&&aC===1&&palace(s,tr,tc);
    case'k':return aR+aC===1&&palace(s,tr,tc);
    case'c':if(!(sr===tr||sc===tc))return false;
             let cnt=0;for(let r=sr+Math.sign(dr),c=sc+Math.sign(dc);
                   r!==tr||c!==tc;r+=Math.sign(dr),c+=Math.sign(dc))
                 if(board[r][c])cnt++;
             return board[tr][tc]?cnt===1:cnt===0;
    case'p':if(s==='red'){if(!across(s,sr)&&dr!==-1)return false;
                          if(across(s,sr))return (dr===-1&&dc===0)||(dr===0&&aC===1);
                          return dr===-1&&dc===0;}
             else{if(!across(s,sr)&&dr!==1)return false;
                  if(across(s,sr))return (dr===1&&dc===0)||(dr===0&&aC===1);
                  return dr===1&&dc===0;}
  }
}

/* ---- AI 相關 ---- */
function canB(b,sr,sc,tr,tc){const tmp=board;board=b;const ok=can(sr,sc,tr,tc);board=tmp;return ok;}
function list(side,b=board){const mv=[];
  for(let r=0;r<ROWS;r++)for(let c=0;c<COLS;c++){
    const p=b[r][c];if(!p||INFO[p].s!==side)continue;
    for(let tr=0;tr<ROWS;tr++)for(let tc=0;tc<COLS;tc++)
      if(canB(b,r,c,tr,tc))mv.push({sr:r,sc:c,tr,tc});
  }return mv;}
const clone=b=>b.map(r=>r.slice()),move=(b,m)=>{const nb=clone(b);
  nb[m.tr][m.tc]=nb[m.sr][m.sc];nb[m.sr][m.sc]=undefined;return nb;};
function evalB(b){let s=0;
  for(let r=0;r<ROWS;r++)for(let c=0;c<COLS;c++){
    const p=b[r][c];if(p){const v=VAL[p.toLowerCase()]||0;
      s+=INFO[p].s==='red'?v:-v;}}
  return s;}
function search(b,d,side,a,beta){
  if(d===0)return evalB(b);
  const mv=list(side,b);if(!mv.length)return side==='red'?-1e5:1e5;
  if(side==='red'){let best=-Infinity;
    for(const m of mv){const v=search(move(b,m),d-1,'black',a,beta);
      best=Math.max(best,v);a=Math.max(a,v);if(beta<=a)break;}
    return best;}
  else{let best=Infinity;
    for(const m of mv){const v=search(move(b,m),d-1,'red',a,beta);
      best=Math.min(best,v);beta=Math.min(beta,v);if(beta<=a)break;}
    return best;}
}
function best(d){
  const mv=list(aiSide);let pick=mv[0],best=aiSide==='red'?-Infinity:Infinity;
  for(const m of mv){const v=search(move(board,m),d-1,aiSide==='red'?'black':'red',-Infinity,Infinity);
    if((aiSide==='red'&&v>best)||(aiSide==='black'&&v<best)){best=v;pick=m;}}
  const rnd=d===1?0.3:d===2?0.1:0;if(Math.random()<rnd)
    pick=mv[Math.floor(Math.random()*mv.length)];
  return pick;
}

/* ---- 繪圖 ---- */
function drawBoard(){
  const cs=getComputedStyle(document.documentElement),
        l=cs.getPropertyValue('--wood-light').trim()||'#f5deb3',
        d=cs.getPropertyValue('--wood-dark').trim()||'#deb887';
  ctx.clearRect(0,0,canvas.width,canvas.height);
  const g=ctx.createLinearGradient(0,0,canvas.width,canvas.height);
  g.addColorStop(0,l);g.addColorStop(1,d);ctx.fillStyle=g;ctx.fillRect(0,0,canvas.width,canvas.height);

  ctx.strokeStyle='var(--line)';ctx.lineWidth=2;
  for(let r=0;r<ROWS;r++){ctx.beginPath();
    ctx.moveTo(CELL/2,CELL/2+r*CELL);
    ctx.lineTo(canvas.width-CELL/2,CELL/2+r*CELL);ctx.stroke();}
  for(let c=0;c<COLS;c++){ctx.beginPath();
    ctx.moveTo(CELL/2+c*CELL,CELL/2);
    ctx.lineTo(CELL/2+c*CELL,CELL/2+4*CELL);ctx.stroke();
    ctx.beginPath();ctx.moveTo(CELL/2+c*CELL,CELL/2+5*CELL);
    ctx.lineTo(CELL/2+c*CELL,CELL/2+9*CELL);ctx.stroke();}

  ctx.font='24px serif';ctx.fillStyle='#444';ctx.textAlign='center';
  ctx.fillText('楚 河',CELL*2.5,CELL*5-12);
  ctx.fillText('漢 界',CELL*6.5,CELL*5-12);
}
function drawPieces(){
  ctx.textAlign='center';ctx.textBaseline='middle';ctx.font='28px serif';
  for(let r=0;r<ROWS;r++)for(let c=0;c<COLS;c++){
    const p=board[r][c];if(!p)continue;
    const {n,side}=INFO[p],x=CELL/2+c*CELL,y=CELL/2+r*CELL;
    ctx.fillStyle='#fff';ctx.beginPath();ctx.arc(x,y,24,0,Math.PI*2);
    ctx.shadowColor='rgba(0,0,0,.25)';ctx.shadowBlur=4;ctx.fill();ctx.shadowBlur=0;
    ctx.strokeStyle='var(--line)';ctx.stroke();
    ctx.fillStyle=side==='red'?'#d32f2f':'#1a237e';ctx.fillText(n,x,y+1);}
  if(selected){ctx.strokeStyle='#2e7d32';ctx.lineWidth=3;
    ctx.strokeRect(selected.sc*CELL+4,selected.sr*CELL+4,CELL-8,CELL-8);}
}
const render=()=>{drawBoard();drawPieces();};

/* ---- 互動 ---- */
function pointer(e){
  if(!running)return;
  const rect=canvas.getBoundingClientRect(),
        x=(e.clientX||e.touches[0].clientX)-rect.left,
        y=(e.clientY||e.touches[0].clientY)-rect.top,
        c=Math.floor(x/CELL),r=Math.floor(y/CELL);
  if(!inR(r,c))return;

  if(selected){
    if(r===selected.sr&&c===selected.sc){selected=null;render();return;}
    if(can(selected.sr,selected.sc,r,c)){move(selected.sr,selected.sc,r,c);}
    else{const p=board[r][c];
         if(p&&INFO[p].s===current){selected={sr:r,sc:c};render();}}
  }else{const p=board[r][c];
        if(p&&INFO[p].s===current){selected={sr:r,sc:c};render();}}
}
canvas.addEventListener('pointerdown',pointer);
canvas.addEventListener('touchstart',pointer);

/* ---- 移動 ---- */
function move(sr,sc,tr,tc){
  moveSound.currentTime=0;moveSound.play();
  const cap=board[tr][tc];
  board[tr][tc]=board[sr][sc];board[sr][sc]=undefined;

  if(cap&&cap.toLowerCase()==='k'){over((current==='red'?'紅':'黑')+'方勝！');return;}

  current=current==='red'?'black':'red';selected=null;
  msgEl.textContent=(current==='red'?'紅':'黑')+'方行棋';
  render();switchTimer(current);
  if(running&&mode==='single'&&current===aiSide) setTimeout(aiMove,300);
}

/* ---- AI ---- */
function aiMove(){
  if(!running)return;
  const m=best(aiDepth);
  if(!m){over('AI 無合法著，'+(aiSide==='red'?'黑':'紅')+'方勝！');return;}
  move(m.sr,m.sc,m.tr,m.tc);
}

/* ---- 結束 ---- */
function over(text){
  running=false;stopTimer();
  msgEl.textContent=text;resultText.textContent=text;
  overlay.classList.add('show');endSound.currentTime=0;endSound.play();
}
function hideOverlay(){overlay.classList.remove('show');}

/* ---- 預渲染空棋盤 ---- */
render();
</script>
</body>
</html>
